# Лабораторная работа: Асинхронное программирование в C#

# Задания

## Задание 1 «Асинхронные вызовы и параллелизм»

### Цель

Понять, как работают `async/await`, как параллельно запускать асинхронные операции и как использовать `CancellationToken` и `try/catch` в асинхронном коде.

### Коротко

Реализовать асинхронный метод-имитатор задержки и вызвать его последовательно и параллельно, собрать результаты и замерить время.

### Требования

1. Сделать метод:

   ```csharp
   async Task<string> GetDataAsync(string name, CancellationToken token)
   {
       await Task.Delay(1000, token); // симуляция I/O
       return $"Data for {name}";
   }
   ```
2. В `Main`:

   * Запустить 3 вызова последовательно (await один за другим), измерить время.
   * Запустить 3 вызова параллельно (через `Task`/`Task.WhenAll`), измерить время.
3. Добавить обработку отмены: создать `CancellationTokenSource`, давать пользователю возможность нажать `c` для отмены. В случае отмены корректно ловить `OperationCanceledException`.
4. Логировать начало/конец каждой задачи и общее время.

### Что должно быть видно

* Разница во времени между последовательным и параллельным запуском.
* Корректная остановка при отмене.
* Корректная обработка исключений (если вызвать `throw` внутри `GetDataAsync`).

---

## Задание 2 «Параллельная загрузка задач с отменой и обработкой ошибок»

### Цель

Разобраться в параллельном запуске большого числа задач, уметь собирать результаты, обрабатывать ошибки и отмену, ограничивать параллелизм.

### Коротко

Эмулировать загрузку 20 элементов: метод `LoadItemAsync(int id, CancellationToken)` случайно делает задержку, иногда выбрасывает исключение; запустить загрузки параллельно с ограничением `maxDegreeOfParallelism`, собрать статистику (успех/ошибки/отмена), записать в логи.

### Требования

1. Метод:

   ```csharp
   async Task<int> LoadItemAsync(int id, CancellationToken token)
   {
       // случайная задержка 100-1000ms
       // 15% шанс выбросить InvalidOperationException
       // поддержка token.ThrowIfCancellationRequested()
       // возвращает id * 10 (пример результата)
   }
   ```
2. В `Main`:

   * Сгенерировать список ID 1..20.
   * Запускать загрузки с ограничением параллелизма (используйте `SemaphoreSlim` или `Parallel.ForEachAsync` / `Task.WhenAll` с семафором).
   * Собрать:

     * числа успешно обработанных элементов,
     * список ошибок (id + ошибка),
     * время выполнения.

   * Реализовать отмену по нажатию `c`.

3. Обработать исключения:

   * Исключения из отдельных задач логировать и продолжать работу (не останавливать весь процесс).
   * Показывать итоговую статистику.

### Что должно быть в выводе

* Количество успешных загрузок, список ошибок, было ли прерывание.
* Пример логов с пометками start/finish/error для каждого id.


