# Лабораторная работа: Многопоточность в C#


## Краткое задание
Напишите небольшое консольное приложение на C#, которое демонстрирует:
- гонку данных и её исправление (`lock` / `Interlocked`),
- паттерн producer–consumer с блокирующей очередью и корректным завершением,


## Задания

### Задание 1 — Гонка данных и её исправление

**Описание:** несколько потоков инкрементируют общий счётчик.

**Что сделать (шаги):**
1. Создайте консольную программу, в которой количество потоков и число, до которого нужно дойти инкрементом, задаются из командной строки.
2. Реализуйте `UnsafeIncrement` (простое `counter++`, без блокирования объекта), замерьте время, покажите итоговое значение инкремента.
3. Реализуйте с помощью `lock(obj)`, замерьте время, покажите итог.
4. Реализуйте с помощью `Interlocked.Increment(ref counter)`,  замерьте время, покажите итог.
5. Выведите таблицу с результатами: метод, время, итоговое значие `counter` для каждого способа.
6. Добавьте вывод шагов (включается отдельно), например, после ввода значений из п.1 можно спросить у пользователя, выводить ли шаги.

---

### Задание 2 — Producer–Consumer

**Описание:** один producer генерирует данные, несколько consumers параллельно обрабатывают элементы.

**Что сделать:**
1. Producer добавляет в очередь 50–100 объектов (например, числа).
2. Воркеры (например, 3 потока или Task) забирают элементы из очереди и «обрабатывают» их (например, умножают число на 2 и ждут 100 мс).
3. После обработки выводят результат.
4. Реализовать механизм остановки:

    * остановить обработку после того, как очередь опустеет,
    * предусмотреть CancellationToken (например, по нажатию клавиши).